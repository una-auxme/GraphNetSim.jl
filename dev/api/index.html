<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GraphNetSim.jl</title><meta name="title" content="API Reference · GraphNetSim.jl"/><meta property="og:title" content="API Reference · GraphNetSim.jl"/><meta property="twitter:title" content="API Reference · GraphNetSim.jl"/><meta name="description" content="Documentation for GraphNetSim.jl."/><meta property="og:description" content="Documentation for GraphNetSim.jl."/><meta property="twitter:description" content="Documentation for GraphNetSim.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Configuration-and-Data-Structures"><span>Configuration and Data Structures</span></a></li><li><a class="tocitem" href="#Training-and-Evaluation"><span>Training and Evaluation</span></a></li><li><a class="tocitem" href="#Training-Strategies"><span>Training Strategies</span></a></li><li><a class="tocitem" href="#Normalization-and-Data-Statistics"><span>Normalization and Data Statistics</span></a></li><li><a class="tocitem" href="#Graph-Construction-and-ODE-Solving"><span>Graph Construction and ODE Solving</span></a></li><li><a class="tocitem" href="#Data-Utilities-and-Conversion"><span>Data Utilities and Conversion</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/una-auxme/GraphNetSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Configuration-and-Data-Structures"><a class="docs-heading-anchor" href="#Configuration-and-Data-Structures">Configuration and Data Structures</a><a id="Configuration-and-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-and-Data-Structures" title="Permalink"></a></h2><h3 id="Args"><a class="docs-heading-anchor" href="#Args">Args</a><a id="Args-1"></a><a class="docs-heading-anchor-permalink" href="#Args" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.Args"><a class="docstring-binding" href="#GraphNetSim.Args"><code>GraphNetSim.Args</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Args</code></pre><p>Configuration structure for training and evaluating Graph Neural Network simulators.</p><p><strong>Fields</strong></p><p><strong>Network Architecture</strong></p><ul><li><code>mps::Integer=15</code>: Number of message passing steps (higher = more expressive but slower)</li><li><code>layer_size::Integer=128</code>: Latent dimension for MLP hidden layers</li><li><code>hidden_layers::Integer=2</code>: Number of hidden layers in each MLP module</li></ul><p><strong>Training Configuration</strong></p><ul><li><code>epochs::Integer=1</code>: Number of passes over the entire dataset</li><li><code>steps::Integer=10e6</code>: Total number of training steps</li><li><code>checkpoint::Integer=10000</code>: Interval (in steps) for saving checkpoints</li><li><code>norm_steps::Integer=1000</code>: Steps to accumulate normalization statistics before weight updates</li><li><code>batchsize::Integer=1</code>: Batch size (currently limited to 1 - full trajectory per batch)</li></ul><p><strong>Normalization</strong></p><ul><li><code>max_norm_steps::Integer=10.0f6</code>: Maximum steps for online normalizer accumulation</li></ul><p><strong>Data Augmentation</strong></p><ul><li><code>types_updated::Vector{Integer}=[1]</code>: Node types whose features are predicted</li><li><code>types_noisy::Vector{Integer}=[0]</code>: Node types to which noise is added during training</li><li><code>noise_stddevs::Vector{Float32}=[0.0f0]</code>: Standard deviations for Gaussian noise (per type or broadcast)</li></ul><p><strong>Training Strategy</strong></p><ul><li><code>training_strategy::TrainingStrategy=DerivativeTraining()</code>: Method for computing loss</li></ul><p><strong>Hardware and Optimization</strong></p><ul><li><code>use_cuda::Bool=true</code>: Enable CUDA GPU acceleration (if available)</li><li><code>gpu_device::Union{Nothing,CuDevice}</code>: CUDA device to use (auto-selected if CUDA functional)</li><li><code>optimizer_learning_rate_start::Float32=1.0f-4</code>: Initial learning rate</li><li><code>optimizer_learning_rate_stop::Union{Nothing,Float32}=nothing</code>: Final learning rate (for decay schedule)</li></ul><p><strong>Validation</strong></p><ul><li><code>show_progress_bars::Bool=true</code>: Show training progress bars</li><li><code>use_valid::Bool=true</code>: Load validation checkpoint (best loss) instead of final checkpoint</li><li><code>solver_valid::OrdinaryDiffEqAlgorithm=Tsit5()</code>: ODE solver for validation rollouts</li><li><code>solver_valid_dt::Union{Nothing,Float32}=nothing</code>: Fixed timestep for validation solver</li><li><code>reset_valid::Bool=false</code>: Reset validation after loading checkpoint</li><li><code>save_step::Bool=false</code>: Save loss at every step (can create large log files)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L45-L88">source</a></section></details></article><h3 id="Dataset"><a class="docs-heading-anchor" href="#Dataset">Dataset</a><a id="Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.Dataset"><a class="docstring-binding" href="#GraphNetSim.Dataset"><code>GraphNetSim.Dataset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Dataset</code></pre><p>A mutable structure containing trajectory data and associated metadata for training, validation, or testing.</p><p><strong>Fields</strong></p><ul><li><code>meta::Dict{String,Any}</code>: Dictionary containing all metadata for the dataset, including feature names, trajectory information, and device settings.</li><li><code>datafile::String</code>: Path to the data file (usually .h5 or .jld2 format).</li><li><code>lock::ReentrantLock</code>: Lock for thread-safe access to the datafile during concurrent operations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L19-L28">source</a></section></details></article><h4 id="Dataset-Constructors"><a class="docs-heading-anchor" href="#Dataset-Constructors">Dataset Constructors</a><a id="Dataset-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Constructors" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="GraphNetSim.Dataset-Tuple{String, String, Any}"><a class="docstring-binding" href="#GraphNetSim.Dataset-Tuple{String, String, Any}"><code>GraphNetSim.Dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dataset(datafile::String, metafile::String, args)</code></pre><p>Construct a Dataset from separate data and metadata files.</p><p>Validates that both files exist and have correct formats (.h5 or .jld2 for data, .json for metadata), then loads trajectories and merges metadata with provided arguments.</p><p><strong>Arguments</strong></p><ul><li><code>datafile::String</code>: Path to the data file (.h5 or .jld2 containing trajectory data).</li><li><code>metafile::String</code>: Path to the metadata file (.json containing dataset configuration).</li><li><code>args</code>: A structure or object whose fields will be merged into the metadata dictionary.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dataset</code>: A new Dataset object initialized with the provided data and metadata.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If datafile or metafile do not exist or have invalid formats.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L35-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.Dataset-Tuple{Symbol, String, Any}"><a class="docstring-binding" href="#GraphNetSim.Dataset-Tuple{Symbol, String, Any}"><code>GraphNetSim.Dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dataset(split::Symbol, path::String, args)</code></pre><p>Construct a Dataset by specifying a split type and directory path.</p><p>Locates and loads the appropriate data file based on the split type (:train, :valid, or :test), expecting a &quot;meta.json&quot; file in the given directory.</p><p><strong>Arguments</strong></p><ul><li><code>split::Symbol</code>: The dataset split, one of <code>:train</code>, <code>:valid</code>, or <code>:test</code>.</li><li><code>path::String</code>: Directory path containing the metadata file &quot;meta.json&quot; and the corresponding data file.</li><li><code>args</code>: A structure or object whose fields will be merged into the metadata dictionary.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dataset</code>: A new Dataset object initialized with data from the specified split.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If split is invalid, if meta.json is not found, or if the corresponding data file cannot be found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L83-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.get_file"><a class="docstring-binding" href="#GraphNetSim.get_file"><code>GraphNetSim.get_file</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_file(split::Symbol, path::String)</code></pre><p>Locate the data file corresponding to a dataset split in the given directory.</p><p>Attempts to find a .jld2 file first, then a .h5 file with the split name (e.g., &quot;train.jld2&quot; or &quot;train.h5&quot;).</p><p><strong>Arguments</strong></p><ul><li><code>split::Symbol</code>: The dataset split name (converted to string).</li><li><code>path::String</code>: Directory path to search for the data file.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the located data file.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If no data file with the specified split name is found in the directory.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L128-L144">source</a></section></details></article><h2 id="Training-and-Evaluation"><a class="docs-heading-anchor" href="#Training-and-Evaluation">Training and Evaluation</a><a id="Training-and-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Training-and-Evaluation" title="Permalink"></a></h2><h3 id="Main-Training-Function"><a class="docs-heading-anchor" href="#Main-Training-Function">Main Training Function</a><a id="Main-Training-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Training-Function" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.train_network"><a class="docstring-binding" href="#GraphNetSim.train_network"><code>GraphNetSim.train_network</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">train_network(opt, ds_path::String, cp_path::String; kws...)</code></pre><p>Train a Graph Neural Network simulator on trajectory data.</p><p>Initializes a graph network, loads dataset, computes normalization statistics,  and performs supervised training using the specified training strategy. Validates  periodically on validation set and saves checkpoints for the best model.</p><p><strong>Arguments</strong></p><ul><li><code>opt</code>: Optimizer configuration (e.g., <code>Optimisers.Adam(1f-4)</code>).</li><li><code>ds_path::String</code>: Path to dataset directory (must contain train, valid, test splits).</li><li><code>cp_path::String</code>: Path where checkpoints and logs are saved.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mps::Int=15</code>: Number of message passing steps in the network.</li><li><code>layer_size::Int=128</code>: Latent dimension of hidden MLP layers.</li><li><code>hidden_layers::Int=2</code>: Number of hidden layers in each MLP.</li><li><code>batchsize::Int=1</code>: Batch size for training (default uses full trajectories).</li><li><code>epochs::Int=1</code>: Number of training epochs.</li><li><code>steps::Int=10e6</code>: Total number of training steps.</li><li><code>checkpoint::Int=10000</code>: Create checkpoint every N steps.</li><li><code>norm_steps::Int=1000</code>: Steps for accumulating normalization statistics without updates.</li><li><code>max_norm_steps::Float32=10.0f6</code>: Maximum steps for online normalizers.</li><li><code>types_updated::Vector{Int}=[1]</code>: Node types whose features are predicted.</li><li><code>types_noisy::Vector{Int}=[0]</code>: Node types to which noise is added.</li><li><code>noise_stddevs::Vector{Float32}=[0.0f0]</code>: Standard deviations for Gaussian noise.</li><li><code>training_strategy::TrainingStrategy=DerivativeTraining()</code>: Training method to use.</li><li><code>use_cuda::Bool=true</code>: Use CUDA GPU if available.</li><li><code>solver_valid::OrdinaryDiffEqAlgorithm=Tsit5()</code>: ODE solver for validation rollouts.</li><li><code>solver_valid_dt::Union{Nothing,Float32}=nothing</code>: Fixed timestep for validation (if set).</li><li><code>optimizer_learning_rate_start::Float32=1.0f-4</code>: Initial learning rate.</li><li><code>optimizer_learning_rate_stop::Union{Nothing,Float32}=nothing</code>: Final learning rate for decay schedule.</li><li><code>show_progress_bars::Bool=true</code>: Show training progress bars.</li><li><code>use_valid::Bool=true</code>: Use validation checkpoint for early stopping.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Minimum validation loss achieved during training.</li></ul><p><strong>Training Strategies</strong></p><ul><li><code>DerivativeTraining</code>: Train on current step derivatives (collocation)</li><li><code>BatchingStrategy</code>: Custom batching of trajectory segments</li></ul><p><strong>Example #TODO add example with different training strategies</strong></p><pre><code class="language-julia hljs">train_network(
    Optimisers.Adam(1f-4),
    &quot;./data&quot;,
    &quot;./checkpoints&quot;;
    epochs=10,
    steps=50000,
    mps=15,
    layer_size=128,
    training_strategy=DerivativeTraining()
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L292-L349">source</a></section></details></article><h3 id="Internal-Training-Functions"><a class="docs-heading-anchor" href="#Internal-Training-Functions">Internal Training Functions</a><a id="Internal-Training-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Training-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.train_gns!"><a class="docstring-binding" href="#GraphNetSim.train_gns!"><code>GraphNetSim.train_gns!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">train_gns!(gns::GraphNetwork, opt_state, ds_train::Dataset, ds_valid::Dataset, df_train, df_valid, df_step, device::Function, cp_path::String, args::Args)</code></pre><p>Execute the main training loop for a Graph Neural Network simulator.</p><p>Performs supervised learning with periodic validation, checkpoint saving, and learning rate scheduling. Supports various training strategies (derivative, batching) and handles feature noise injection, gradient accumulation over multiple time steps, and online normalizer updates.</p><p><strong>Arguments</strong></p><ul><li><code>gns::GraphNetwork</code>: Graph network model containing parameters and normalizers.</li><li><code>opt_state</code>: Optimizer state from Optimisers.jl.</li><li><code>ds_train::Dataset</code>: Training dataset with trajectories and metadata.</li><li><code>ds_valid::Dataset</code>: Validation dataset for monitoring training progress.</li><li><code>df_train</code>: DataFrame storing training loss at checkpoints.</li><li><code>df_valid</code>: DataFrame storing best validation losses.</li><li><code>df_step</code>: DataFrame storing loss at each step (if save_step enabled).</li><li><code>device::Function</code>: Device placement function (cpu<em>device or gpu</em>device).</li><li><code>cp_path::String</code>: Path for saving checkpoints and logs.</li><li><code>args::Args</code>: Configuration including optimizer, strategy, and training parameters.</li></ul><p><strong>Algorithm</strong></p><p>For each training step:</p><ol><li>Prepare input data and compute node features</li><li>For each time step in trajectory:<ul><li>Build computation graph with neighborhood connections</li><li>Forward pass through network</li><li>Compute loss depending on training strategy</li><li>Accumulate gradients</li></ul></li><li>Update parameters after accumulation window</li><li>Optionally decay learning rate</li><li>Every N steps: validate on full trajectories and save checkpoint if improved</li></ol><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Minimum validation loss achieved.</li></ul><p><strong>Notes</strong></p><ul><li>First <code>norm_steps</code> steps only accumulate normalization statistics</li><li>Validation using long trajectory rollouts occurs at checkpoint intervals</li><li>Checkpoints saved to <code>cp_path/valid</code> when validation loss improves</li><li>Final checkpoint always saved at <code>cp_path</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L432-L474">source</a></section></details></article><h3 id="Normalization-Setup"><a class="docs-heading-anchor" href="#Normalization-Setup">Normalization Setup</a><a id="Normalization-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization-Setup" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.calc_norms"><a class="docstring-binding" href="#GraphNetSim.calc_norms"><code>GraphNetSim.calc_norms</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calc_norms(dataset::Dataset, device::Function, args::Args)</code></pre><p>Initialize and compute feature normalizers from dataset statistics.</p><p>Computes normalization statistics for edge features, node features, and output features based on metadata specifications. Supports offline min/max and mean/std normalization, boolean encoding, one-hot encoded features, and online accumulation strategies.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::Dataset</code>: Dataset object containing feature metadata and specifications.</li><li><code>device::Function</code>: Device placement function (cpu<em>device or gpu</em>device).</li><li><code>args::Args</code>: Configuration struct with norm_steps for online normalizer accumulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: (quantities, e<em>norms, n</em>norms, o_norms)<ul><li><code>quantities::Int</code>: Total number of input feature dimensions</li><li><code>e_norms</code>: Dictionary or single normalizer for edge features</li><li><code>n_norms::Dict</code>: Dictionary mapping node feature names to normalizers</li><li><code>o_norms::Dict</code>: Dictionary mapping output feature names to normalizers</li></ul></li></ul><p><strong>Normalizer Types</strong></p><ul><li><code>NormaliserOfflineMinMax</code>: Fixed min/max normalization with learnable target range</li><li><code>NormaliserOfflineMeanStd</code>: Fixed mean/standard deviation normalization</li><li><code>NormaliserOnline</code>: Accumulates statistics online during training</li></ul><p><strong>Notes</strong></p><ul><li>One-hot encoded Int32 features are expanded to multiple dimensions</li><li>Boolean features are mapped to [0.0, 1.0] range</li><li>Distance features add dimensions for domain boundary constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L115-L145">source</a></section></details></article><h3 id="Main-Evaluation-Function"><a class="docs-heading-anchor" href="#Main-Evaluation-Function">Main Evaluation Function</a><a id="Main-Evaluation-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Evaluation-Function" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.eval_network"><a class="docstring-binding" href="#GraphNetSim.eval_network"><code>GraphNetSim.eval_network</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eval_network(ds_path::String, cp_path::String, out_path::String, solver=nothing; start, stop, dt=nothing, saves, mse_steps, kws...)</code></pre><p>Evaluate a trained Graph Neural Network simulator on test trajectories.</p><p>Loads a trained network from checkpoint, performs long-term trajectory rollouts, computes error metrics against ground truth, and saves results to disk.</p><p><strong>Arguments</strong></p><ul><li><code>ds_path::String</code>: Path to dataset directory containing test split.</li><li><code>cp_path::String</code>: Path to checkpoint directory (contains model parameters).</li><li><code>out_path::String</code>: Path where evaluation results are saved.</li><li><code>solver</code>: ODE solver for long-term predictions (e.g., <code>Tsit5()</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start::Real</code>: Start time for evaluation.</li><li><code>stop::Real</code>: End time for evaluation.</li><li><code>saves::AbstractVector</code>: Time points where solution is saved.</li><li><code>mse_steps::AbstractVector</code>: Time points where error metrics are computed.</li><li><code>dt::Union{Nothing,Real}=nothing</code>: Fixed timestep for solver (if applicable).</li><li><code>mps::Int=15</code>: Number of message passing steps (must match training config).</li><li><code>layer_size::Int=128</code>: Hidden layer size (must match training config).</li><li><code>hidden_layers::Int=2</code>: Number of hidden layers (must match training config).</li><li><code>types_updated::Vector{Int}=[1]</code>: Updated node types (must match training config).</li><li><code>use_cuda::Bool=true</code>: Use CUDA GPU if available.</li><li><code>use_valid::Bool=true</code>: Load from best validation checkpoint instead of final checkpoint.</li></ul><p><strong>Output</strong></p><p>Saves results to <code>out_path/{solver_name}/trajectories.h5</code>:</p><ul><li>Ground truth positions, velocities, accelerations</li><li>Predicted positions, velocities, accelerations</li><li>Prediction errors for each trajectory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">eval_network(
    &quot;./data&quot;,
    &quot;./checkpoints&quot;,
    &quot;./results&quot;;
    solver=Tsit5(),
    start=0.0f0,
    stop=1.0f0,
    dt=0.01f0,
    saves=0.0:0.01:1.0,
    mse_steps=0.0:0.1:1.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L728-L779">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.eval_network!"><a class="docstring-binding" href="#GraphNetSim.eval_network!"><code>GraphNetSim.eval_network!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eval_network!(solver, gns::GraphNetwork, ds_test::Dataset, device::Function, out_path::String, start::Real, stop::Real, dt, saves, mse_steps, args::Args)</code></pre><p>Perform evaluation loops and trajectory rollouts for all test samples.</p><p>Executes long-term predictions for each test trajectory, computes performance metrics relative to ground truth, and saves trajectories and errors to HDF5 format.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: ODE solver for trajectory rollouts (or <code>nothing</code> for collocation).</li><li><code>gns::GraphNetwork</code>: Trained graph network model.</li><li><code>ds_test::Dataset</code>: Test dataset with trajectories.</li><li><code>device::Function</code>: Device placement function.</li><li><code>out_path::String</code>: Output directory for results.</li><li><code>start::Real</code>: Evaluation start time.</li><li><code>stop::Real</code>: Evaluation end time.</li><li><code>dt</code>: Fixed timestep (or <code>nothing</code> for adaptive).</li><li><code>saves</code>: Time points to save solution.</li><li><code>mse_steps</code>: Time points to compute errors.</li><li><code>args::Args</code>: Configuration parameters.</li></ul><p><strong>Algorithm</strong></p><p>For each test trajectory:</p><ol><li>Extract initial conditions from data</li><li>Create computation graph with graph network</li><li>Roll out trajectory using ODE solver for specified duration</li><li>Extract position, velocity, and acceleration from solution</li><li>Compute mean squared error against ground truth</li><li>Report cumulative error at specified time points</li></ol><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: (traj_ops, errors)<ul><li><code>traj_ops::Dict</code>: Dictionary of trajectories with ground truth and predictions</li><li><code>errors::Dict</code>: Squared errors for each trajectory</li></ul></li></ul><p><strong>Output Files</strong></p><p>Creates <code>{out_path}/{solver_name}/trajectories.h5</code> containing:</p><ul><li>Ground truth and predicted trajectories</li><li>Error fields for each time step</li><li>Properly indexed for easy post-processing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/GraphNetSim.jl#L851-L894">source</a></section></details></article><h2 id="Training-Strategies"><a class="docs-heading-anchor" href="#Training-Strategies">Training Strategies</a><a id="Training-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Training-Strategies" title="Permalink"></a></h2><h3 id="Abstract-Base-Type"><a class="docs-heading-anchor" href="#Abstract-Base-Type">Abstract Base Type</a><a id="Abstract-Base-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Base-Type" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.prepare_training"><a class="docstring-binding" href="#GraphNetSim.prepare_training"><code>GraphNetSim.prepare_training</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepare_training(strategy)</code></pre><p>Function that is executed once before training. Can be overwritten by training strategies if necessary.</p><p><strong>Arguments</strong></p><ul><li><code>strategy</code>: Used training strategy.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple containing the results of the function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L18-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.get_delta"><a class="docstring-binding" href="#GraphNetSim.get_delta"><code>GraphNetSim.get_delta</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_delta(strategy, trajectory_length)</code></pre><p>Returns the delta between samples in the training data.</p><p><strong>Arguments</strong></p><ul><li><code>strategy</code>: Used training strategy.</li><li>Trajectory length (used for Derivative strategies).</li></ul><p><strong>Returns</strong></p><ul><li>Delta between samples in the training data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L33-L44">source</a></section><section><div><pre><code class="language-julia hljs">get_delta(::SolverStrategy, ::Integer)</code></pre><p>Returns the delta (step size) for solver-based training strategies.</p><p>For most solver-based strategies, returns 1 (advancing by single timestep). Can be overridden by specific strategies (e.g., <code>BatchingStrategy</code>).</p><p><strong>Arguments</strong></p><ul><li><code>strategy::SolverStrategy</code>: Solver-based training strategy.</li><li><code>trajectory_length::Integer</code>: Length of the trajectory (unused in base implementation).</li></ul><p><strong>Returns</strong></p><ul><li>Integer delta between training samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L191-L205">source</a></section><section><div><pre><code class="language-julia hljs">get_delta(strategy::BatchingStrategy, ::Integer)</code></pre><p>Returns the number of steps per batch.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::BatchingStrategy</code>: BatchingStrategy instance.</li><li>Unused trajectory length parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Integer</code>: Number of steps per batch (strategy.steps).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L464-L475">source</a></section><section><div><pre><code class="language-julia hljs">get_delta(strategy::DerivativeStrategy, trajectory_length)</code></pre><p>Returns the effective trajectory length for derivative training.</p><p>If strategy window<em>size &gt; 0 and smaller than trajectory</em>length, returns window<em>size. Otherwise returns the full trajectory</em>length.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::DerivativeStrategy</code>: Derivative-based strategy.</li><li><code>trajectory_length::Integer</code>: Length of the trajectory.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L967-L978">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.init_train_step"><a class="docstring-binding" href="#GraphNetSim.init_train_step"><code>GraphNetSim.init_train_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init_train_step(strategy, t)</code></pre><p>Function that is executed before each training sample.</p><p><strong>Arguments</strong></p><ul><li><code>strategy</code>: Used training strategy.</li><li><code>t</code>: Tuple containing the variables necessary for initializing training.</li><li><code>ta</code>: Tuple with additional variables that is returned from <a href="#GraphNetSim.prepare_training">prepare_training</a>.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple containing variables needed for <a href="#GraphNetSim.train_step">train_step</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L53-L65">source</a></section><section><div><pre><code class="language-julia hljs">init_train_step(strategy::SolverStrategy, t::Tuple)</code></pre><p>Initializes a training step for solver-based strategies.</p><p>Extracts initial conditions, packs state into ComponentArray format, and prepares ground truth data for ODE problem setup.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::SolverStrategy</code>: Solver-based training strategy.</li><li><code>t::Tuple</code>: Input tuple containing (gns, data, position, velocity, meta, output<em>fields, target</em>fields, node_type, mask, device, ...).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Initialized data for training step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L210-L224">source</a></section><section><div><pre><code class="language-julia hljs">init_train_step(strategy::BatchingStrategy, t::Tuple)</code></pre><p>Initializes a training step for the BatchingStrategy.</p><p>Selects the next batch via <code>nextBatch()</code>, extracts initial conditions for that time window, packs state into ComponentArray, and prepares ground truth data.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::BatchingStrategy</code>: BatchingStrategy instance.</li><li><code>t::Tuple</code>: Input tuple (gns, data, meta, output<em>fields, target</em>fields, node<em>type, mask, val</em>mask, device, <em>, batches, show</em>progress_bars).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Initialized batch data for training step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L537-L551">source</a></section><section><div><pre><code class="language-julia hljs">init_train_step(strategy::DerivativeStrategy, t::Tuple)</code></pre><p>Initializes a training step for derivative-based strategies.</p><p>Extracts target derivatives at a single datapoint and normalizes using network feature normalizers.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::DerivativeStrategy</code>: Derivative-based strategy.</li><li><code>t::Tuple</code>: Input tuple with network, data, and sampling information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L987-L998">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.train_step"><a class="docstring-binding" href="#GraphNetSim.train_step"><code>GraphNetSim.train_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">train_step(strategy, t)</code></pre><p>Performs a single training step and return the resulting gradients and loss.</p><p><strong>Arguments</strong></p><ul><li><code>strategy</code>: Solver strategy that is used for training.</li><li><code>t</code>: Tuple that is returned from <a href="#GraphNetSim.init_train_step"><code>init_train_step</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>Gradients for optimization step.</li><li>Loss for optimization step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L74-L86">source</a></section><section><div><pre><code class="language-julia hljs">train_step(strategy::SolverStrategy, t::Tuple)</code></pre><p>Performs one training step for solver-based strategies.</p><p>Constructs an ODE problem from the GNS model, solves it using the strategy&#39;s solver, and computes gradients via sensitivity analysis (adjoint method).</p><p><strong>Arguments</strong></p><ul><li><code>strategy::SolverStrategy</code>: Solver-based training strategy.</li><li><code>t::Tuple</code>: Initialized data from <code>init_train_step()</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: (gradients, loss) - Gradients for optimization and scalar training loss.</li></ul><p><strong>Algorithm</strong></p><ol><li>Create ODE right-hand side function using <code>ode_func_train()</code>.</li><li>Setup ODE problem with initial conditions and parameters.</li><li>Compute loss via <code>train_loss()</code>.</li><li>Backpropagate through ODE solver using sensitivity algorithm.</li><li>Return gradients and loss.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L272-L293">source</a></section><section><div><pre><code class="language-julia hljs">train_step(strategy::BatchingStrategy, t::Tuple)</code></pre><p>Performs one training step for the BatchingStrategy.</p><p>Constructs an ODE problem for the selected batch, solves it using the strategy&#39;s solver, and computes gradients via sensitivity analysis. Updates batch loss.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::BatchingStrategy</code>: BatchingStrategy instance.</li><li><code>t::Tuple</code>: Data tuple from init<em>train</em>step().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L600-L611">source</a></section><section><div><pre><code class="language-julia hljs">train_step(strategy::DerivativeStrategy, t::Tuple)</code></pre><p>Performs one training step for derivative-based strategies.</p><p>Evaluates network on graph at a single timepoint and computes loss against target derivatives. Computes gradients via backpropagation.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::DerivativeStrategy</code>: Derivative-based strategy.</li><li><code>t::Tuple</code>: Data tuple from init<em>train</em>step().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L1011-L1022">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.validation_step"><a class="docstring-binding" href="#GraphNetSim.validation_step"><code>GraphNetSim.validation_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">validation_step(strategy, t)</code></pre><p>Performs validation of a single trajectory. Should be overwritten by training strategies to determine simulation and data interval before calling the inner function <a href="#GraphNetSim._validation_step"><code>_validation_step</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>strategy</code>: Type of training strategy (used for dispatch).</li><li><code>t</code>: Tuple containing the variables necessary for validation.</li></ul><p><strong>Returns</strong></p><ul><li>See <a href="#GraphNetSim._validation_step"><code>_validation_step</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L95-L106">source</a></section><section><div><pre><code class="language-julia hljs">validation_step(strategy::SolverStrategy, t::Tuple)</code></pre><p>Validation step for solver-based strategies.</p><p>Computes validation loss by rolling out the GNS model over the full validation trajectory and comparing predicted outputs with ground truth.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::SolverStrategy</code>: Solver-based training strategy.</li><li><code>t::Tuple</code>: Validation data tuple containing (gns, data, meta, ...).</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Validation loss (mean squared error).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L359-L373">source</a></section><section><div><pre><code class="language-julia hljs">validation_step(strategy::DerivativeStrategy, t::Tuple)</code></pre><p>Validation step for derivative-based strategies.</p><p>Computes validation loss by rolling out GNS model over trajectory window and comparing derivatives with ground truth.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::DerivativeStrategy</code>: Derivative-based strategy.</li><li><code>t::Tuple</code>: Validation data tuple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L1108-L1119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim._validation_step"><a class="docstring-binding" href="#GraphNetSim._validation_step"><code>GraphNetSim._validation_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_validation_step(t, sim_interval, data_interval)</code></pre><p>Inner function for validation of a single trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: Tuple containing the variables necessary for validation.</li><li><code>sim_interval</code>: Interval that determines the simulated time for the validation.</li><li><code>data_interval</code>: Interval that determines the indices of the timesteps in ground truth and prediction data.</li></ul><p><strong>Returns</strong></p><ul><li>Loss calculated on the difference between ground truth and prediction (via mse).</li><li>Ground truth data with <code>data_interval</code> as timesteps.</li><li>Prediction data with <code>data_interval</code> as timesteps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L115-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.batchTrajectory"><a class="docstring-binding" href="#GraphNetSim.batchTrajectory"><code>GraphNetSim.batchTrajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">batchTrajectory(strategy::BatchingStrategy, data::Dict)</code></pre><p>Partitions a trajectory into time intervals (batches) for sequential training.</p><p>Divides the full trajectory duration into equal-sized time intervals, creating one Batch object per interval. Used for memory-efficient training on long sequences.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::BatchingStrategy</code>: Batching strategy with interval specifications.</li><li><code>data::Dict</code>: Data dictionary containing <code>&quot;dt&quot;</code> (timestep) and <code>&quot;trajectory_length&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Batch}</code>: Array of Batch objects partitioning the trajectory.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L480-L494">source</a></section></details></article><h3 id="Concrete-Strategies"><a class="docs-heading-anchor" href="#Concrete-Strategies">Concrete Strategies</a><a id="Concrete-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Strategies" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.SingleShooting"><a class="docstring-binding" href="#GraphNetSim.SingleShooting"><code>GraphNetSim.SingleShooting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SingleShooting(tstart, dt, tstop, solver; sense = InterpolatingAdjoint(autojacvec = ZygoteVJP()), solargs...)</code></pre><p>The default solver based training that is normally used for NeuralODEs. Simulates the system from <code>tstart</code> to <code>tstop</code> and calculates the loss based on the difference between the prediction and the ground truth at the timesteps <code>tstart:dt:tstop</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tstart</code>: Start time of the simulation.</li><li><code>dt</code>: Interval at which the simulation is saved.</li><li><code>tstop</code>: Stop time of the simulation.</li><li><code>solver</code>: Solver that is used for simulating the system.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sense = InterpolatingAdjoint(autojacvec = ZygoteVJP())</code>: The sensitivity algorithm that is used for caluclating the sensitivities.</li><li><code>solargs</code>: Keyword arguments that are passed on to the solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L703-L718">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.MultipleShooting"><a class="docstring-binding" href="#GraphNetSim.MultipleShooting"><code>GraphNetSim.MultipleShooting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultipleShooting(tstart, dt, tstop, solver, interval_size, continuity_term = 100; sense = InterpolatingAdjoint(autojacvec = ZygoteVJP(), checkpointing = true), solargs...)</code></pre><p>Similar to SingleShooting, but splits the trajectory into intervals that are solved independently and then combines them for loss calculation. Useful if the network tends to get stuck in a local minimum if SingleShooting is used.</p><p><strong>Arguments</strong></p><ul><li><code>tstart</code>: Start time of the simulation.</li><li><code>dt</code>: Interval at which the simulation is saved.</li><li><code>tstop</code>: Stop time of the simulation.</li><li><code>solver</code>: Solver that is used for simulating the system.</li><li><code>interval_size</code>: Size of the intervals (i.e. number of datapoints in one interval).</li><li><code>continuity_term = 100</code>: Factor by which the error between points of concurrent intervals is multiplied.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sense = InterpolatingAdjoint(autojacvec = ZygoteVJP(), checkpointing = true)</code>:</li><li><code>solargs</code>: Keyword arguments that are passed on to the solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L823-L840">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.DerivativeTraining"><a class="docstring-binding" href="#GraphNetSim.DerivativeTraining"><code>GraphNetSim.DerivativeTraining</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DerivativeTraining &lt;: DerivativeStrategy</code></pre><p>Derivative-based training strategy using finite-difference ground truth.</p><p>Compares network output with finite-difference derivatives from data. Faster than solver-based training, useful for initial model training. Supports temporal windowing and optional random shuffling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L1134-L1142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.BatchingStrategy"><a class="docstring-binding" href="#GraphNetSim.BatchingStrategy"><code>GraphNetSim.BatchingStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BatchingStrategy &lt;: SolverStrategy</code></pre><p>Solver-based training strategy that batches long trajectories into segments.</p><p>Divides long trajectories into time intervals and solves/trains on each segment independently. Useful for memory-efficient training on long sequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/strategies.jl#L389-L396">source</a></section></details></article><h2 id="Normalization-and-Data-Statistics"><a class="docs-heading-anchor" href="#Normalization-and-Data-Statistics">Normalization and Data Statistics</a><a id="Normalization-and-Data-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization-and-Data-Statistics" title="Permalink"></a></h2><h3 id="Computing-Normalization-Statistics"><a class="docs-heading-anchor" href="#Computing-Normalization-Statistics">Computing Normalization Statistics</a><a id="Computing-Normalization-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Normalization-Statistics" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.data_minmax"><a class="docstring-binding" href="#GraphNetSim.data_minmax"><code>GraphNetSim.data_minmax</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">data_minmax(path)</code></pre><p>Calculates the minimum and maximum values for each numeric feature across all dataset partitions.</p><p>Iterates through training, validation, and test datasets to compute global min/max bounds for all numeric features (Int32 and Float32 types).</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Path to the dataset files.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Dictionary mapping feature names to [min, max] value pairs computed from all datasets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/utils.jl#L53-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.data_meanstd"><a class="docstring-binding" href="#GraphNetSim.data_meanstd"><code>GraphNetSim.data_meanstd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">data_meanstd(path)</code></pre><p>Calculates the mean and standard deviation for each feature in the given part of the dataset.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Path to the dataset files.</li></ul><p><strong>Returns</strong></p><ul><li>Mean and standard deviation in training, validation and test set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/utils.jl#L171-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphNetSim.der_minmax"><a class="docstring-binding" href="#GraphNetSim.der_minmax"><code>GraphNetSim.der_minmax</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">der_minmax(path)</code></pre><p>Calculates the minimum and maximum across training, validation, and test sets for each numeric feature.</p><p>Combines results from both training/validation and test data to compute overall min/max bounds.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Path to the dataset files.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Dictionary mapping feature names to [min, max] value pairs across all datasets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/utils.jl#L25-L37">source</a></section></details></article><h2 id="Graph-Construction-and-ODE-Solving"><a class="docs-heading-anchor" href="#Graph-Construction-and-ODE-Solving">Graph Construction and ODE Solving</a><a id="Graph-Construction-and-ODE-Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Construction-and-ODE-Solving" title="Permalink"></a></h2><h3 id="Building-Computation-Graphs"><a class="docs-heading-anchor" href="#Building-Computation-Graphs">Building Computation Graphs</a><a id="Building-Computation-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Computation-Graphs" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.build_graph"><a class="docstring-binding" href="#GraphNetSim.build_graph"><code>GraphNetSim.build_graph</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_graph(gns::GraphNetCore.GraphNetwork, data::Dict{String,Any}, datapoint::Integer, meta, node_type, device)</code></pre><p>Construct a <a href="https://una-auxme.github.io/MeshGraphNets.jl/dev/graph_net_core/#GraphNetCore.FeatureGraph">FeatureGraph</a> from trajectory data at a specific time step.</p><p>Extracts position and velocity data from the trajectory dictionary at the given time point, then delegates to the second method to construct the graph with edge connectivity and normalized features.</p><p><strong>Arguments</strong></p><ul><li><code>gns::GraphNetCore.GraphNetwork</code>: Graph network model containing normalizers for features.</li><li><code>data::Dict{String,Any}</code>: Dictionary containing trajectory data (position, velocity, etc.).</li><li><code>datapoint::Integer</code>: Time step index to extract from the trajectory.</li><li><code>meta::Dict{String,Any}</code>: Metadata dictionary with connectivity and feature settings.</li><li><code>node_type</code>: One-hot encoded node type features.</li><li><code>device::Function</code>: Device placement function (cpu or gpu).</li></ul><p><strong>Returns</strong></p><ul><li><code>GraphNetCore.FeatureGraph</code>: Constructed graph with normalized node and edge features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/graph.jl#L12-L30">source</a></section><section><div><pre><code class="language-julia hljs">build_graph(gns::GraphNetCore.GraphNetwork, position, velocity, meta, node_type, mask, device)</code></pre><p>Construct a <a href="https://una-auxme.github.io/MeshGraphNets.jl/dev/graph_net_core/#GraphNetCore.FeatureGraph">FeatureGraph</a> from position and velocity data with edge connectivity.</p><p>Computes edges based on spatial proximity using GPU-accelerated neighborhood search, calculates relative displacements and normalized distances. Node features are constructed from position, velocity, node type, and distance bounds to domain boundaries. All features are normalized using the normalizers stored in the model.</p><p><strong>Arguments</strong></p><ul><li><code>gns::GraphNetCore.GraphNetwork</code>: Graph network model containing normalizers.</li><li><code>position::AbstractArray</code>: Particle positions with shape (dims, n_particles).</li><li><code>velocity::AbstractArray</code>: Particle velocities with shape (dims, n_particles).</li><li><code>meta::Dict{String,Any}</code>: Metadata with default<em>connectivity</em>radius, bounds, dims, input_features, and device settings.</li><li><code>node_type::AbstractArray</code>: One-hot encoded node type features.</li><li><code>mask::AbstractVector</code>: Indices of particles to include in the graph (fluid particles).</li><li><code>device::Function</code>: Device placement function.</li></ul><p><strong>Returns</strong></p><ul><li><code>GraphNetCore.FeatureGraph</code>: Graph with normalized node features, normalized edge features, sender and receiver indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/graph.jl#L54-L74">source</a></section></details></article><h3 id="ODE-Integration"><a class="docs-heading-anchor" href="#ODE-Integration">ODE Integration</a><a id="ODE-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-Integration" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.rollout"><a class="docstring-binding" href="#GraphNetSim.rollout"><code>GraphNetSim.rollout</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rollout(solver, gns::GraphNetwork, initial_state, output_fields, meta, target_fields, node_type, mask, val_mask, start, stop, dt, saves, device; pr=nothing)</code></pre><p>Solves the ODE problem for a Graph Neural Network simulator using the given solver and computes solution at specified timesteps.</p><p>Solves the ODEProblem of the GNS model over the specified time interval. The function handles both fixed and adaptive timestep solvers, with optional progress reporting.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: ODE solver algorithm (e.g., <code>Tsit5()</code>, <code>RK4()</code>) from OrdinaryDiffEq.jl.</li><li><code>gns::GraphNetwork</code>: Graph neural network model to evaluate for dynamics.</li><li><code>initial_state::Dict</code>: Dictionary with <code>&quot;position&quot;</code> and <code>&quot;velocity&quot;</code> arrays for initial conditions.</li><li><code>output_fields::Vector{String}</code>: Names of output features predicted by the network.</li><li><code>meta::Dict</code>: Dataset metadata containing feature dimensions and specifications.</li><li><code>target_fields::Vector{String}</code>: Names of target (output) features.</li><li><code>node_type::Vector</code>: One-hot encoded node type indicators.</li><li><code>mask::Vector</code>: Boolean mask for valid nodes in graph.</li><li><code>val_mask::Vector</code>: Validation/evaluation mask for output features.</li><li><code>start::Float32</code>: Start time of ODE integration.</li><li><code>stop::Float32</code>: Stop time of ODE integration.</li><li><code>dt::Union{Nothing,Float32}</code>: Fixed timestep (if <code>nothing</code>, uses adaptive timestepping).</li><li><code>saves::Vector</code>: Timesteps where solution should be saved.</li><li><code>device::Function</code>: Device placement function (cpu<em>device or gpu</em>device).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pr::Union{Nothing,ProgressBar}=nothing</code>: Progress bar for tracking ODE solve.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol</code>: Solution object containing state trajectories at specified <code>saves</code> timesteps.</li></ul><p><strong>Notes</strong></p><ul><li>Uses <code>ode_step_eval()</code> as the right-hand side function for the ODE.</li><li>State is packed as <code>ComponentArray</code> with <code>x</code> (position) and <code>dx</code> (velocity) fields.</li><li>Output features are denormalized using stored normalizers before return.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/solve.jl#L11-L44">source</a></section></details></article><h2 id="Data-Utilities-and-Conversion"><a class="docs-heading-anchor" href="#Data-Utilities-and-Conversion">Data Utilities and Conversion</a><a id="Data-Utilities-and-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Utilities-and-Conversion" title="Permalink"></a></h2><h3 id="Dataset-Loading"><a class="docs-heading-anchor" href="#Dataset-Loading">Dataset Loading</a><a id="Dataset-Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Loading" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.keystraj"><a class="docstring-binding" href="#GraphNetSim.keystraj"><code>GraphNetSim.keystraj</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">keystraj(datafile::String)</code></pre><p>Extract trajectory keys from a data file.</p><p>Opens either a .jld2 or .h5 file and returns all top-level keys, representing individual trajectories stored in the file.</p><p><strong>Arguments</strong></p><ul><li><code>datafile::String</code>: Path to the data file (.h5 or .jld2).</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{String,1}</code>: Array of trajectory keys from the file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L156-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MLCore.getobs!"><a class="docstring-binding" href="#MLCore.getobs!"><code>MLCore.getobs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MLUtils.getobs!(buffer::Dict{String,Any}, ds::Dataset, idx::Int)</code></pre><p>Load trajectory data into a pre-allocated buffer using the MLUtils interface.</p><p>Retrieves a single trajectory by index, populates all metadata and features into the provided buffer dictionary, and applies trajectory preparation (device transfer, masking, validation masks). Modifies the buffer in-place.</p><p><strong>Arguments</strong></p><ul><li><code>buffer::Dict{String,Any}</code>: Pre-allocated dictionary to store trajectory data (modified in-place).</li><li><code>ds::Dataset</code>: The dataset object.</li><li><code>idx::Int</code>: Index of the trajectory to retrieve (1-indexed).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Any}</code>: The modified buffer containing the trajectory data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/dataset.jl#L183-L198">source</a></section></details></article><h3 id="Format-Conversion"><a class="docs-heading-anchor" href="#Format-Conversion">Format Conversion</a><a id="Format-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Format-Conversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.csv_to_hdf5"><a class="docstring-binding" href="#GraphNetSim.csv_to_hdf5"><code>GraphNetSim.csv_to_hdf5</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">csv_to_hdf5(source::String, output::String; 
             dt::Float64=0.01, 
             n_trajectories::Int=1,
             dims::Vector{Int}=[1, 2],
             groupby_col::Symbol=:Idp,
             interpolation_scheme::String=&quot;pchip&quot;,
             pos_col_prefix::String=&quot;Points&quot;,
             vel_col_prefix::String=&quot;Vel&quot;,
             type_col::Symbol=:Type,
             extra_fields::Vector{Symbol}=Symbol[])</code></pre><p>Convert particle trajectory data from CSV to HDF5 format with computed accelerations.</p><p><strong>Arguments</strong></p><ul><li><code>source::String</code>: Path to input CSV file</li><li><code>output::String</code>: Path to output HDF5 file</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dt::Float64</code>: Time step (default: 0.01)</li><li><code>n_trajectories::Int</code>: Number of trajectories to process (default: 1)</li><li><code>dims::Vector{Int}</code>: Spatial dimensions to extract, e.g. [1, 2] or [1, 3].<code>(default: [1, 2])</code></li><li><code>groupby_col::Symbol</code>: Column name for grouping particles (default: :Idp)</li><li><code>interpolation_scheme::String</code>: Acceleration calculation method (default: &quot;pchip&quot;)<ul><li>&quot;central_diff&quot;: Central difference scheme</li><li>&quot;forward_diff&quot;: Forward difference scheme</li><li>&quot;backward_diff&quot;: Backward difference scheme</li><li>&quot;from_pos&quot;: Acceleration from position (2nd order central difference)</li><li>&quot;pchip&quot;: PCHIP interpolation of velocity derivatives</li><li>&quot;linear&quot;: LinearInterpolation</li><li>&quot;quadratic&quot;: QuadraticInterpolation</li><li>&quot;cubic_spline&quot;: CubicSpline</li><li>&quot;quadratic_spline&quot;: QuadraticSpline</li><li>&quot;cubic_hermite&quot;: CubicHermiteSpline</li><li>&quot;lagrange&quot;: LagrangeInterpolation</li><li>&quot;akima&quot;: AkimaInterpolation</li></ul></li><li><code>pos_col_prefix::String</code>: Prefix for position columns (default: &quot;Points&quot;)</li><li><code>vel_col_prefix::String</code>: Prefix for velocity columns (default: &quot;Vel&quot;)</li><li><code>type_col::Symbol</code>: Column name for particle type (default: :Type)</li><li><code>extra_fields::Vector{Symbol}</code>: Additional CSV columns to copy to HDF5  (e.g. [:Mass, :Temperature])</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 3D simulation with PCHIP interpolation
csv_to_hdf5(&quot;data/dam_break.csv&quot;, &quot;data/dam_break_first.h5&quot;; 
            dt=0.01, dims=[1, 2, 3], interpolation_scheme=&quot;pchip&quot;)

# 2D (skip y-dimension), with extra fields
csv_to_hdf5(&quot;data/input.csv&quot;, &quot;output.h5&quot;; 
            dims=[1, 3], interpolation_scheme=&quot;cubic_spline&quot;,
            extra_fields=[:Mass, :Pressure])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/convert_csv/csvToh5.jl#L11-L64">source</a></section></details></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><h3 id="VTK-Export"><a class="docs-heading-anchor" href="#VTK-Export">VTK Export</a><a id="VTK-Export-1"></a><a class="docs-heading-anchor-permalink" href="#VTK-Export" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="GraphNetSim.visualize"><a class="docstring-binding" href="#GraphNetSim.visualize"><code>GraphNetSim.visualize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visualize(inPath, outFolder, Position, subgroupTrajectory, Parameters, Trajectorys, NumberOfTimesteps)</code></pre><p>Reads HDF5 file into dictionary and writes VTK HDF5 file format with dictToVTKHDF().</p><p>Input file must have a group for each trajectory and subgroups for all trajectories used. Datasets are linked to each subgroup of trajectory. If only certain trajectories should be written, specify them with a Vector{Int} (minimum is 1). Validation contains the names of the subgroups which will be written and each trajectory must have the same number of timesteps.</p><p>Timesteps can be automatically detected if dataset &quot;timesteps&quot; is linked to each trajectory group. This dataset must contain the number for the largest timestep and timesteps 1:1:max will be read. When using timesteps, all datasets to be read need &quot;[Int]&quot; appended.</p><p><strong>Arguments</strong></p><ul><li><code>inPath::String</code>: Complete path ending with .h5 file.</li><li><code>outFolder::String</code>: Complete path for output folder.</li><li><code>Position::String</code>: Name of HDF5 dataset for position data.</li><li><code>subgroupTrajectory::String</code>: Name of subgroup within trajectory groups.</li><li><code>Parameters::Vector{String}</code>: Names of other HDF5 datasets to read (optional).</li><li><code>Trajectorys::Union{Vector{Int},Nothing}</code>: Trajectory indices to write (optional, auto-detected if nothing).</li><li><code>NumberOfTimesteps::Union{Vector{Int},Nothing}</code>: Timesteps to write (optional, auto-detected if nothing).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Dictionary mapping (trajectory, dataset_name, timestep) tuples to numerical arrays.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/una-auxme/GraphNetSim.jl/blob/ff8a89ed584104edddd936d6324fff8a8fba736f/src/visualize.jl#L8-L34">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 15:37">Saturday 28 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
